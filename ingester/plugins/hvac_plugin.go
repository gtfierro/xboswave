// This file is AUTOGENERATED
package main

import "github.com/gtfierro/xboswave/ingester/types"
import xbospb "github.com/gtfierro/xboswave/proto"
import "fmt"

func has_ahu(msg xbospb.XBOS) bool {
	return msg.XBOSIoTDeviceState.AHU != nil
}

func has_economizer(msg xbospb.XBOS) bool {
	return msg.XBOSIoTDeviceState.Economizer != nil
}

func has_vav(msg xbospb.XBOS) bool {
	return msg.XBOSIoTDeviceState.VAV != nil
}

func has_damper(msg xbospb.XBOS) bool {
	return msg.XBOSIoTDeviceState.Damper != nil
}

func has_fan(msg xbospb.XBOS) bool {
	return msg.XBOSIoTDeviceState.Fan != nil
}

var ahu_lookup = map[string]func(msg xbospb.XBOS) (float64, bool){
	//"discharge_air_temperature_setpoint":
	"discharge_air_temperature_setpoint": func(msg xbospb.XBOS) (float64, bool) {
		if has_ahu(msg) && msg.XBOSIoTDeviceState.AHU.DischargeAirTemperatureSetpoint != nil {
			return float64(msg.XBOSIoTDeviceState.AHU.DischargeAirTemperatureSetpoint.Value), true
		}
		return 0, false
	},
	"outside_air_temperature_sensor": func(msg xbospb.XBOS) (float64, bool) {
		if has_ahu(msg) && msg.XBOSIoTDeviceState.AHU.OutsideAirTemperatureSensor != nil {
			return float64(msg.XBOSIoTDeviceState.AHU.OutsideAirTemperatureSensor.Value), true
		}
		return 0, false
	},
	"heating_valve_command": func(msg xbospb.XBOS) (float64, bool) {
		if has_ahu(msg) && msg.XBOSIoTDeviceState.AHU.HeatingValveCommand != nil {
			return float64(msg.XBOSIoTDeviceState.AHU.HeatingValveCommand.Value), true
		}
		return 0, false
	},
	"discharge_air_static_pressure_sensor": func(msg xbospb.XBOS) (float64, bool) {
		if has_ahu(msg) && msg.XBOSIoTDeviceState.AHU.DischargeAirStaticPressureSensor != nil {
			return float64(msg.XBOSIoTDeviceState.AHU.DischargeAirStaticPressureSensor.Value), true
		}
		return 0, false
	},
	"cooling_demand": func(msg xbospb.XBOS) (float64, bool) {
		if has_ahu(msg) && msg.XBOSIoTDeviceState.AHU.CoolingDemand != nil {
			return float64(msg.XBOSIoTDeviceState.AHU.CoolingDemand.Value), true
		}
		return 0, false
	},
	"cooling_valve_command": func(msg xbospb.XBOS) (float64, bool) {
		if has_ahu(msg) && msg.XBOSIoTDeviceState.AHU.CoolingValveCommand != nil {
			return float64(msg.XBOSIoTDeviceState.AHU.CoolingValveCommand.Value), true
		}
		return 0, false
	},
	"mixed_air_temperature_sensor": func(msg xbospb.XBOS) (float64, bool) {
		if has_ahu(msg) && msg.XBOSIoTDeviceState.AHU.MixedAirTemperatureSensor != nil {
			return float64(msg.XBOSIoTDeviceState.AHU.MixedAirTemperatureSensor.Value), true
		}
		return 0, false
	},
	"building_static_pressure_sensor": func(msg xbospb.XBOS) (float64, bool) {
		if has_ahu(msg) && msg.XBOSIoTDeviceState.AHU.BuildingStaticPressureSensor != nil {
			return float64(msg.XBOSIoTDeviceState.AHU.BuildingStaticPressureSensor.Value), true
		}
		return 0, false
	},
	"filter_status": func(msg xbospb.XBOS) (float64, bool) {
		if has_ahu(msg) && msg.XBOSIoTDeviceState.AHU.FilterStatus != nil {
			return float64(msg.XBOSIoTDeviceState.AHU.FilterStatus.Value), true
		}
		return 0, false
	},
	"discharge_air_temperature_sensor": func(msg xbospb.XBOS) (float64, bool) {
		if has_ahu(msg) && msg.XBOSIoTDeviceState.AHU.DischargeAirTemperatureSensor != nil {
			return float64(msg.XBOSIoTDeviceState.AHU.DischargeAirTemperatureSensor.Value), true
		}
		return 0, false
	},
	"building_static_pressure_setpoint": func(msg xbospb.XBOS) (float64, bool) {
		if has_ahu(msg) && msg.XBOSIoTDeviceState.AHU.BuildingStaticPressureSetpoint != nil {
			return float64(msg.XBOSIoTDeviceState.AHU.BuildingStaticPressureSetpoint.Value), true
		}
		return 0, false
	},
	"discharge_air_static_pressure_setpoint": func(msg xbospb.XBOS) (float64, bool) {
		if has_ahu(msg) && msg.XBOSIoTDeviceState.AHU.DischargeAirStaticPressureSetpoint != nil {
			return float64(msg.XBOSIoTDeviceState.AHU.DischargeAirStaticPressureSetpoint.Value), true
		}
		return 0, false
	},
	"occupancy_command": func(msg xbospb.XBOS) (float64, bool) {
		if has_ahu(msg) && msg.XBOSIoTDeviceState.AHU.OccupancyCommand != nil {
			return float64(msg.XBOSIoTDeviceState.AHU.OccupancyCommand.Value), true
		}
		return 0, false
	},
	"return_air_temperature_sensor": func(msg xbospb.XBOS) (float64, bool) {
		if has_ahu(msg) && msg.XBOSIoTDeviceState.AHU.ReturnAirTemperatureSensor != nil {
			return float64(msg.XBOSIoTDeviceState.AHU.ReturnAirTemperatureSensor.Value), true
		}
		return 0, false
	},
	"zone_temperature_sensor": func(msg xbospb.XBOS) (float64, bool) {
		if has_ahu(msg) && msg.XBOSIoTDeviceState.AHU.ZoneTemperatureSensor != nil {
			return float64(msg.XBOSIoTDeviceState.AHU.ZoneTemperatureSensor.Value), true
		}
		return 0, false
	},
	"supply_air_damper_min_position_setpoint": func(msg xbospb.XBOS) (float64, bool) {
		if has_ahu(msg) && msg.XBOSIoTDeviceState.AHU.SupplyAirDamperMinPositionSetpoint != nil {
			return float64(msg.XBOSIoTDeviceState.AHU.SupplyAirDamperMinPositionSetpoint.Value), true
		}
		return 0, false
	},
	"mixed_air_temperature_setpoint": func(msg xbospb.XBOS) (float64, bool) {
		if has_ahu(msg) && msg.XBOSIoTDeviceState.AHU.MixedAirTemperatureSetpoint != nil {
			return float64(msg.XBOSIoTDeviceState.AHU.MixedAirTemperatureSetpoint.Value), true
		}
		return 0, false
	},
	"occupied_mode_status": func(msg xbospb.XBOS) (float64, bool) {
		if has_ahu(msg) && msg.XBOSIoTDeviceState.AHU.OccupiedModeStatus != nil {
			return float64(msg.XBOSIoTDeviceState.AHU.OccupiedModeStatus.Value), true
		}
		return 0, false
	},
	"shutdown_command": func(msg xbospb.XBOS) (float64, bool) {
		if has_ahu(msg) && msg.XBOSIoTDeviceState.AHU.ShutdownCommand != nil {
			return float64(msg.XBOSIoTDeviceState.AHU.ShutdownCommand.Value), true
		}
		return 0, false
	},
	"mixed_air_temperature_low_limit_setpoint": func(msg xbospb.XBOS) (float64, bool) {
		if has_ahu(msg) && msg.XBOSIoTDeviceState.AHU.MixedAirTemperatureLowLimitSetpoint != nil {
			return float64(msg.XBOSIoTDeviceState.AHU.MixedAirTemperatureLowLimitSetpoint.Value), true
		}
		return 0, false
	},
	"zone_temperature_setpoint": func(msg xbospb.XBOS) (float64, bool) {
		if has_ahu(msg) && msg.XBOSIoTDeviceState.AHU.ZoneTemperatureSetpoint != nil {
			return float64(msg.XBOSIoTDeviceState.AHU.ZoneTemperatureSetpoint.Value), true
		}
		return 0, false
	},
}

var units = map[string]string{
	"discharge_air_temperature_setpoint":       "unknown",
	"outside_air_temperature_sensor":           "unknown",
	"heating_valve_command":                    "unknown",
	"discharge_air_static_pressure_sensor":     "unknown",
	"cooling_demand":                           "unknown",
	"cooling_valve_command":                    "unknown",
	"mixed_air_temperature_sensor":             "unknown",
	"building_static_pressure_sensor":          "unknown",
	"filter_status":                            "unknown",
	"discharge_air_temperature_sensor":         "unknown",
	"building_static_pressure_setpoint":        "unknown",
	"discharge_air_static_pressure_setpoint":   "unknown",
	"occupancy_command":                        "unknown",
	"return_air_temperature_sensor":            "unknown",
	"zone_temperature_sensor":                  "unknown",
	"supply_air_damper_min_position_setpoint":  "unknown",
	"mixed_air_temperature_setpoint":           "unknown",
	"occupied_mode_status":                     "unknown",
	"shutdown_command":                         "unknown",
	"mixed_air_temperature_low_limit_setpoint": "unknown",
	"zone_temperature_setpoint":                "unknown",
	"vav":                                      "unknown",
	"vvt":                                      "unknown",
}

func build(uri types.SubscriptionURI, name string, msg xbospb.XBOS) types.ExtractedTimeseries {

	if has_ahu(msg) {
		if extractfunc, found := ahu_lookup[name]; found {
			if value, found := extractfunc(msg); found {
				var extracted types.ExtractedTimeseries
				time := int64(msg.XBOSIoTDeviceState.Time)
				extracted.Values = append(extracted.Values, value)
				extracted.Times = append(extracted.Times, time)
				extracted.UUID = types.GenerateUUID(uri, []byte(name))
				extracted.Collection = fmt.Sprintf("jeditest/opl1/%s", uri.Resource)
				extracted.Tags = map[string]string{
					"unit": ahu_units[name],
					"name": name,
				}
				return extracted
			}
		}
	}

	return types.ExtractedTimeseries{}
}

func Extract(uri types.SubscriptionURI, msg xbospb.XBOS, add func(types.ExtractedTimeseries) error) error {
	if msg.XBOSIoTDeviceState != nil {
		if has_meter(msg) || has_light(msg) || has_tstat(msg) {
			for name := range lookup {
				extracted := build(uri, name, msg)
				if extracted.Empty() {
					continue
				}
				if err := add(extracted); err != nil {
					return err
				}
			}
		}
	}
	return nil
}
