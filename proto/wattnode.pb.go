// Code generated by protoc-gen-go. DO NOT EDIT.
// source: wattnode.proto

package xbospb

import (
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

type WattnodeState struct {
	//total net (bidirectional) energy - preserved across power failures; can be reset or preset
	//unit: kWh
	EnergySum *Double `protobuf:"bytes,1,opt,name=EnergySum,proto3" json:"EnergySum,omitempty"`
	//total positive energy - preserved across power failures; can be reset or preset
	//unit: kWh
	EnergyPosSum *Double `protobuf:"bytes,2,opt,name=EnergyPosSum,proto3" json:"EnergyPosSum,omitempty"`
	//total net (bidirectional) energy - non resettable and preserved across power failures
	//unit: kWh
	EnergySumNR *Double `protobuf:"bytes,3,opt,name=EnergySumNR,proto3" json:"EnergySumNR,omitempty"`
	//total positive energy - non resettable and preserverd across power failures
	//unit: kWh
	EnergyPosSumNr *Double `protobuf:"bytes,4,opt,name=EnergyPosSumNr,proto3" json:"EnergyPosSumNr,omitempty"`
	//real power; sum of active phases
	//unit: W
	PowerSum *Double `protobuf:"bytes,5,opt,name=PowerSum,proto3" json:"PowerSum,omitempty"`
	//real power; phase A
	//unit: W
	PowerA *Double `protobuf:"bytes,6,opt,name=PowerA,proto3" json:"PowerA,omitempty"`
	//real power; phase B
	//unit: W
	PowerB *Double `protobuf:"bytes,7,opt,name=PowerB,proto3" json:"PowerB,omitempty"`
	//real power; phase C
	//unit: W
	PowerC *Double `protobuf:"bytes,8,opt,name=PowerC,proto3" json:"PowerC,omitempty"`
	//average line-to-neutral voltage
	//unit: V
	VoltAvgLN *Double `protobuf:"bytes,9,opt,name=VoltAvgLN,proto3" json:"VoltAvgLN,omitempty"`
	//RMS voltage; phase A to neutral
	//unit: V
	VoltA *Double `protobuf:"bytes,10,opt,name=VoltA,proto3" json:"VoltA,omitempty"`
	//RMS voltage; phase B to neutral
	//unit: V
	VoltB *Double `protobuf:"bytes,11,opt,name=VoltB,proto3" json:"VoltB,omitempty"`
	//RMS voltage; phase C to neutral
	//unit: V
	VoltC *Double `protobuf:"bytes,12,opt,name=VoltC,proto3" json:"VoltC,omitempty"`
	//average line-to-line voltage
	//unit: V
	VoltAvgLL *Double `protobuf:"bytes,13,opt,name=VoltAvgLL,proto3" json:"VoltAvgLL,omitempty"`
	//RMS voltage; line-to-line; phase A to B
	//unit: V
	VoltAB *Double `protobuf:"bytes,14,opt,name=VoltAB,proto3" json:"VoltAB,omitempty"`
	//RMS voltage; line-to-line; phase B to C
	//unit: V
	VoltBC *Double `protobuf:"bytes,15,opt,name=VoltBC,proto3" json:"VoltBC,omitempty"`
	//RMS voltage; line-to-line; phase A to C
	//unit: V
	VoltAC *Double `protobuf:"bytes,16,opt,name=VoltAC,proto3" json:"VoltAC,omitempty"`
	//power line frequency
	//unit: Hz
	Freq *Double `protobuf:"bytes,17,opt,name=Freq,proto3" json:"Freq,omitempty"`
	//phase A net (bidirectional) energy - preserved across power failures; can be reset or preset
	//unit: kWh
	EnergyA *Double `protobuf:"bytes,18,opt,name=EnergyA,proto3" json:"EnergyA,omitempty"`
	//phase B net (bidirectional) energy - preserved across power failures; can be reset or preset
	//unit: kWh
	EnergyB *Double `protobuf:"bytes,19,opt,name=EnergyB,proto3" json:"EnergyB,omitempty"`
	//phase C net (bidirectional) energy - preserved across power failures; can be reset or preset
	//unit: kWh
	EnergyC *Double `protobuf:"bytes,20,opt,name=EnergyC,proto3" json:"EnergyC,omitempty"`
	//phase A positive energy - preserved across power failures; can be reset or preset
	//unit: kWh
	EnergyPosA *Double `protobuf:"bytes,21,opt,name=EnergyPosA,proto3" json:"EnergyPosA,omitempty"`
	//phase B positive energy - preserved across power failures; can be reset or preset
	//unit: kWh
	EnergyPosB *Double `protobuf:"bytes,22,opt,name=EnergyPosB,proto3" json:"EnergyPosB,omitempty"`
	//phase C positive energy - preserved across power failures; can be reset or preset
	//unit: kWh
	EnergyPosC *Double `protobuf:"bytes,23,opt,name=EnergyPosC,proto3" json:"EnergyPosC,omitempty"`
	//total negative energy; sum of active phases - preserved across power failures; can be reset or preset
	//unit: kWh
	EnergyNegSum *Double `protobuf:"bytes,24,opt,name=EnergyNegSum,proto3" json:"EnergyNegSum,omitempty"`
	//total negative energy; sum of active phases - non resettable and preserved across power failures
	//unit: kWh
	EnergyNegSumNR *Double `protobuf:"bytes,25,opt,name=EnergyNegSumNR,proto3" json:"EnergyNegSumNR,omitempty"`
	//phase A negative energy - preserved across power failures; can be reset or preset
	//unit: kWh
	EnergyNegA *Double `protobuf:"bytes,26,opt,name=EnergyNegA,proto3" json:"EnergyNegA,omitempty"`
	//phase B negative energy - preserved across power failures; can be reset or preset
	//unit: kWh
	EnergyNegB *Double `protobuf:"bytes,27,opt,name=EnergyNegB,proto3" json:"EnergyNegB,omitempty"`
	//phase C negative energy - preserved across power failures; can be reset or preset
	//unit: kWh
	EnergyNegC *Double `protobuf:"bytes,28,opt,name=EnergyNegC,proto3" json:"EnergyNegC,omitempty"`
	//reactive energy; sum of active phases - preserved across power failures; can be reset or preset
	//unit: kVARh
	EnergyReacSum *Double `protobuf:"bytes,29,opt,name=EnergyReacSum,proto3" json:"EnergyReacSum,omitempty"`
	//phase A net reactive energy - preserved across power failures; can be reset or preset
	//unit: kVARh
	EnergyReacA *Double `protobuf:"bytes,30,opt,name=EnergyReacA,proto3" json:"EnergyReacA,omitempty"`
	//phase B net reactive energy - preserved across power failures; can be reset or preset
	//unit: kVARh
	EnergyReacB *Double `protobuf:"bytes,31,opt,name=EnergyReacB,proto3" json:"EnergyReacB,omitempty"`
	//phase C net reactive energy - preserved across power failures; can be reset or preset
	//unit: kVARh
	EnergyReacC *Double `protobuf:"bytes,32,opt,name=EnergyReacC,proto3" json:"EnergyReacC,omitempty"`
	//total apparent energy; sum of active phases - preserved across power failures; can be reset or preset
	//unit: kVAh
	EnergyAppSum *Double `protobuf:"bytes,33,opt,name=EnergyAppSum,proto3" json:"EnergyAppSum,omitempty"`
	//phase A apparent energy - preserved across power failures; can be reset or preset
	//unit: kVAh
	EnergyAppA *Double `protobuf:"bytes,34,opt,name=EnergyAppA,proto3" json:"EnergyAppA,omitempty"`
	//phase B apparent energy - preserved across power failures; can be reset or preset
	//unit: kVAh
	EnergyAppB *Double `protobuf:"bytes,35,opt,name=EnergyAppB,proto3" json:"EnergyAppB,omitempty"`
	//phase C apparent energy - preserved across power failures; can be reset or preset
	//unit: kVAh
	EnergyAppC *Double `protobuf:"bytes,36,opt,name=EnergyAppC,proto3" json:"EnergyAppC,omitempty"`
	//average power factor
	PowerFactorAvg *Double `protobuf:"bytes,37,opt,name=PowerFactorAvg,proto3" json:"PowerFactorAvg,omitempty"`
	//phase A power factor
	PowerFactorA *Double `protobuf:"bytes,38,opt,name=PowerFactorA,proto3" json:"PowerFactorA,omitempty"`
	//phase B power factor
	PowerFactorB *Double `protobuf:"bytes,39,opt,name=PowerFactorB,proto3" json:"PowerFactorB,omitempty"`
	//phase C power factor
	PowerFactorC *Double `protobuf:"bytes,40,opt,name=PowerFactorC,proto3" json:"PowerFactorC,omitempty"`
	//total reactive power; sum of active phases
	//unit: VAR
	PowerReacSum *Double `protobuf:"bytes,41,opt,name=PowerReacSum,proto3" json:"PowerReacSum,omitempty"`
	//phase A reactive power
	//unit: VAR
	PowerReacA *Double `protobuf:"bytes,42,opt,name=PowerReacA,proto3" json:"PowerReacA,omitempty"`
	//phase B reactive power
	//unit: VAR
	PowerReacB *Double `protobuf:"bytes,43,opt,name=PowerReacB,proto3" json:"PowerReacB,omitempty"`
	//phase C reactive power
	//unit: VAR
	PowerReacC *Double `protobuf:"bytes,44,opt,name=PowerReacC,proto3" json:"PowerReacC,omitempty"`
	//total apparent power; sum of active phases
	//unit: VA
	PowerAppSum *Double `protobuf:"bytes,45,opt,name=PowerAppSum,proto3" json:"PowerAppSum,omitempty"`
	//phase A apparent power
	//unit: VA
	PowerAppA *Double `protobuf:"bytes,46,opt,name=PowerAppA,proto3" json:"PowerAppA,omitempty"`
	//phase B apparent power
	//unit: VA
	PowerAppB *Double `protobuf:"bytes,47,opt,name=PowerAppB,proto3" json:"PowerAppB,omitempty"`
	//phase C apparent power
	//unit: VA
	PowerAppC *Double `protobuf:"bytes,48,opt,name=PowerAppC,proto3" json:"PowerAppC,omitempty"`
	//RMS current; phase A
	//unit: A
	CurrentA *Double `protobuf:"bytes,49,opt,name=CurrentA,proto3" json:"CurrentA,omitempty"`
	//RMS current; phase B
	//unit: A
	CurrentB *Double `protobuf:"bytes,50,opt,name=CurrentB,proto3" json:"CurrentB,omitempty"`
	//RMS current; phase C
	//unit: A
	CurrentC *Double `protobuf:"bytes,51,opt,name=CurrentC,proto3" json:"CurrentC,omitempty"`
	//real power demand average over demand period
	//unit: W
	Demand *Double `protobuf:"bytes,52,opt,name=Demand,proto3" json:"Demand,omitempty"`
	//minimum power demand
	//unit: W
	DemandMin *Double `protobuf:"bytes,53,opt,name=DemandMin,proto3" json:"DemandMin,omitempty"`
	//maximum power demand
	//unit: W
	DemandMax *Double `protobuf:"bytes,54,opt,name=DemandMax,proto3" json:"DemandMax,omitempty"`
	//apparent power demand
	//unit: W
	DemandApp *Double `protobuf:"bytes,55,opt,name=DemandApp,proto3" json:"DemandApp,omitempty"`
	//phase A real power demand
	//unit: W
	DemandA *Double `protobuf:"bytes,56,opt,name=DemandA,proto3" json:"DemandA,omitempty"`
	//phase B real power demand
	//unit: W
	DemandB *Double `protobuf:"bytes,57,opt,name=DemandB,proto3" json:"DemandB,omitempty"`
	//phase C real power demand
	//unit: W
	DemandC *Double `protobuf:"bytes,58,opt,name=DemandC,proto3" json:"DemandC,omitempty"`
	//epoch time
	Time                 uint64   `protobuf:"varint,59,opt,name=time,proto3" json:"time,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *WattnodeState) Reset()         { *m = WattnodeState{} }
func (m *WattnodeState) String() string { return proto.CompactTextString(m) }
func (*WattnodeState) ProtoMessage()    {}
func (*WattnodeState) Descriptor() ([]byte, []int) {
	return fileDescriptor_73d9fd4fa3213993, []int{0}
}

func (m *WattnodeState) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_WattnodeState.Unmarshal(m, b)
}
func (m *WattnodeState) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_WattnodeState.Marshal(b, m, deterministic)
}
func (m *WattnodeState) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WattnodeState.Merge(m, src)
}
func (m *WattnodeState) XXX_Size() int {
	return xxx_messageInfo_WattnodeState.Size(m)
}
func (m *WattnodeState) XXX_DiscardUnknown() {
	xxx_messageInfo_WattnodeState.DiscardUnknown(m)
}

var xxx_messageInfo_WattnodeState proto.InternalMessageInfo

func (m *WattnodeState) GetEnergySum() *Double {
	if m != nil {
		return m.EnergySum
	}
	return nil
}

func (m *WattnodeState) GetEnergyPosSum() *Double {
	if m != nil {
		return m.EnergyPosSum
	}
	return nil
}

func (m *WattnodeState) GetEnergySumNR() *Double {
	if m != nil {
		return m.EnergySumNR
	}
	return nil
}

func (m *WattnodeState) GetEnergyPosSumNr() *Double {
	if m != nil {
		return m.EnergyPosSumNr
	}
	return nil
}

func (m *WattnodeState) GetPowerSum() *Double {
	if m != nil {
		return m.PowerSum
	}
	return nil
}

func (m *WattnodeState) GetPowerA() *Double {
	if m != nil {
		return m.PowerA
	}
	return nil
}

func (m *WattnodeState) GetPowerB() *Double {
	if m != nil {
		return m.PowerB
	}
	return nil
}

func (m *WattnodeState) GetPowerC() *Double {
	if m != nil {
		return m.PowerC
	}
	return nil
}

func (m *WattnodeState) GetVoltAvgLN() *Double {
	if m != nil {
		return m.VoltAvgLN
	}
	return nil
}

func (m *WattnodeState) GetVoltA() *Double {
	if m != nil {
		return m.VoltA
	}
	return nil
}

func (m *WattnodeState) GetVoltB() *Double {
	if m != nil {
		return m.VoltB
	}
	return nil
}

func (m *WattnodeState) GetVoltC() *Double {
	if m != nil {
		return m.VoltC
	}
	return nil
}

func (m *WattnodeState) GetVoltAvgLL() *Double {
	if m != nil {
		return m.VoltAvgLL
	}
	return nil
}

func (m *WattnodeState) GetVoltAB() *Double {
	if m != nil {
		return m.VoltAB
	}
	return nil
}

func (m *WattnodeState) GetVoltBC() *Double {
	if m != nil {
		return m.VoltBC
	}
	return nil
}

func (m *WattnodeState) GetVoltAC() *Double {
	if m != nil {
		return m.VoltAC
	}
	return nil
}

func (m *WattnodeState) GetFreq() *Double {
	if m != nil {
		return m.Freq
	}
	return nil
}

func (m *WattnodeState) GetEnergyA() *Double {
	if m != nil {
		return m.EnergyA
	}
	return nil
}

func (m *WattnodeState) GetEnergyB() *Double {
	if m != nil {
		return m.EnergyB
	}
	return nil
}

func (m *WattnodeState) GetEnergyC() *Double {
	if m != nil {
		return m.EnergyC
	}
	return nil
}

func (m *WattnodeState) GetEnergyPosA() *Double {
	if m != nil {
		return m.EnergyPosA
	}
	return nil
}

func (m *WattnodeState) GetEnergyPosB() *Double {
	if m != nil {
		return m.EnergyPosB
	}
	return nil
}

func (m *WattnodeState) GetEnergyPosC() *Double {
	if m != nil {
		return m.EnergyPosC
	}
	return nil
}

func (m *WattnodeState) GetEnergyNegSum() *Double {
	if m != nil {
		return m.EnergyNegSum
	}
	return nil
}

func (m *WattnodeState) GetEnergyNegSumNR() *Double {
	if m != nil {
		return m.EnergyNegSumNR
	}
	return nil
}

func (m *WattnodeState) GetEnergyNegA() *Double {
	if m != nil {
		return m.EnergyNegA
	}
	return nil
}

func (m *WattnodeState) GetEnergyNegB() *Double {
	if m != nil {
		return m.EnergyNegB
	}
	return nil
}

func (m *WattnodeState) GetEnergyNegC() *Double {
	if m != nil {
		return m.EnergyNegC
	}
	return nil
}

func (m *WattnodeState) GetEnergyReacSum() *Double {
	if m != nil {
		return m.EnergyReacSum
	}
	return nil
}

func (m *WattnodeState) GetEnergyReacA() *Double {
	if m != nil {
		return m.EnergyReacA
	}
	return nil
}

func (m *WattnodeState) GetEnergyReacB() *Double {
	if m != nil {
		return m.EnergyReacB
	}
	return nil
}

func (m *WattnodeState) GetEnergyReacC() *Double {
	if m != nil {
		return m.EnergyReacC
	}
	return nil
}

func (m *WattnodeState) GetEnergyAppSum() *Double {
	if m != nil {
		return m.EnergyAppSum
	}
	return nil
}

func (m *WattnodeState) GetEnergyAppA() *Double {
	if m != nil {
		return m.EnergyAppA
	}
	return nil
}

func (m *WattnodeState) GetEnergyAppB() *Double {
	if m != nil {
		return m.EnergyAppB
	}
	return nil
}

func (m *WattnodeState) GetEnergyAppC() *Double {
	if m != nil {
		return m.EnergyAppC
	}
	return nil
}

func (m *WattnodeState) GetPowerFactorAvg() *Double {
	if m != nil {
		return m.PowerFactorAvg
	}
	return nil
}

func (m *WattnodeState) GetPowerFactorA() *Double {
	if m != nil {
		return m.PowerFactorA
	}
	return nil
}

func (m *WattnodeState) GetPowerFactorB() *Double {
	if m != nil {
		return m.PowerFactorB
	}
	return nil
}

func (m *WattnodeState) GetPowerFactorC() *Double {
	if m != nil {
		return m.PowerFactorC
	}
	return nil
}

func (m *WattnodeState) GetPowerReacSum() *Double {
	if m != nil {
		return m.PowerReacSum
	}
	return nil
}

func (m *WattnodeState) GetPowerReacA() *Double {
	if m != nil {
		return m.PowerReacA
	}
	return nil
}

func (m *WattnodeState) GetPowerReacB() *Double {
	if m != nil {
		return m.PowerReacB
	}
	return nil
}

func (m *WattnodeState) GetPowerReacC() *Double {
	if m != nil {
		return m.PowerReacC
	}
	return nil
}

func (m *WattnodeState) GetPowerAppSum() *Double {
	if m != nil {
		return m.PowerAppSum
	}
	return nil
}

func (m *WattnodeState) GetPowerAppA() *Double {
	if m != nil {
		return m.PowerAppA
	}
	return nil
}

func (m *WattnodeState) GetPowerAppB() *Double {
	if m != nil {
		return m.PowerAppB
	}
	return nil
}

func (m *WattnodeState) GetPowerAppC() *Double {
	if m != nil {
		return m.PowerAppC
	}
	return nil
}

func (m *WattnodeState) GetCurrentA() *Double {
	if m != nil {
		return m.CurrentA
	}
	return nil
}

func (m *WattnodeState) GetCurrentB() *Double {
	if m != nil {
		return m.CurrentB
	}
	return nil
}

func (m *WattnodeState) GetCurrentC() *Double {
	if m != nil {
		return m.CurrentC
	}
	return nil
}

func (m *WattnodeState) GetDemand() *Double {
	if m != nil {
		return m.Demand
	}
	return nil
}

func (m *WattnodeState) GetDemandMin() *Double {
	if m != nil {
		return m.DemandMin
	}
	return nil
}

func (m *WattnodeState) GetDemandMax() *Double {
	if m != nil {
		return m.DemandMax
	}
	return nil
}

func (m *WattnodeState) GetDemandApp() *Double {
	if m != nil {
		return m.DemandApp
	}
	return nil
}

func (m *WattnodeState) GetDemandA() *Double {
	if m != nil {
		return m.DemandA
	}
	return nil
}

func (m *WattnodeState) GetDemandB() *Double {
	if m != nil {
		return m.DemandB
	}
	return nil
}

func (m *WattnodeState) GetDemandC() *Double {
	if m != nil {
		return m.DemandC
	}
	return nil
}

func (m *WattnodeState) GetTime() uint64 {
	if m != nil {
		return m.Time
	}
	return 0
}

func init() {
	proto.RegisterType((*WattnodeState)(nil), "xbospb.WattnodeState")
}

func init() { proto.RegisterFile("wattnode.proto", fileDescriptor_73d9fd4fa3213993) }

var fileDescriptor_73d9fd4fa3213993 = []byte{
	// 673 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x84, 0xd6, 0x5b, 0x53, 0x13, 0x31,
	0x14, 0x07, 0xf0, 0x41, 0x4b, 0x81, 0x00, 0x55, 0x83, 0xe8, 0x5f, 0xbc, 0x21, 0x22, 0x56, 0xc4,
	0x8a, 0x80, 0x78, 0x7b, 0xca, 0x09, 0xf2, 0x84, 0x1d, 0xa6, 0xcc, 0xe8, 0xf3, 0x16, 0x32, 0x1d,
	0x66, 0xca, 0xee, 0xba, 0x6c, 0xb9, 0x7c, 0x1a, 0xbf, 0xaa, 0x93, 0x4d, 0xf7, 0x12, 0x26, 0x64,
	0xdf, 0x36, 0x3d, 0xbf, 0x93, 0x49, 0xb2, 0x27, 0x7b, 0xca, 0x5a, 0x97, 0x41, 0x9a, 0x86, 0xd1,
	0x89, 0xea, 0xc4, 0x49, 0x94, 0x46, 0xbc, 0x79, 0xd5, 0x8f, 0xce, 0xe3, 0xfe, 0xd2, 0x42, 0x38,
	0x1a, 0x0e, 0x83, 0xfe, 0x50, 0xa5, 0xd7, 0xb1, 0x3a, 0x37, 0xc1, 0x95, 0x7f, 0x8b, 0x6c, 0xfe,
	0xcf, 0xd8, 0x1f, 0xa5, 0x41, 0xaa, 0xf8, 0x06, 0x9b, 0xf9, 0x19, 0xaa, 0x64, 0x70, 0x7d, 0x34,
	0x3a, 0xc3, 0xc4, 0xf2, 0x44, 0x7b, 0x76, 0xab, 0xd5, 0x31, 0x53, 0x74, 0xf6, 0xa2, 0x51, 0x7f,
	0xa8, 0x7a, 0x25, 0xe0, 0x5b, 0x6c, 0xce, 0x0c, 0x0e, 0xa3, 0x73, 0x9d, 0x70, 0xc7, 0x99, 0x60,
	0x19, 0xbe, 0xc9, 0x66, 0x8b, 0x09, 0xba, 0x3d, 0xdc, 0x75, 0xa6, 0x54, 0x09, 0xdf, 0x65, 0xad,
	0xea, 0x0c, 0xdd, 0x04, 0x0d, 0x67, 0xd2, 0x0d, 0xc5, 0xd7, 0xd9, 0xf4, 0x61, 0x74, 0xa9, 0x12,
	0xbd, 0xb2, 0x49, 0x67, 0x46, 0x11, 0xe7, 0x6b, 0xac, 0x99, 0x3d, 0x0b, 0x34, 0x9d, 0x72, 0x1c,
	0x2d, 0x1c, 0x61, 0xca, 0xe3, 0xa8, 0x70, 0x12, 0xd3, 0x1e, 0x27, 0xf5, 0x79, 0xff, 0x8e, 0x86,
	0xa9, 0xb8, 0x18, 0x1c, 0x74, 0x31, 0xe3, 0x3e, 0xef, 0x02, 0xf0, 0x55, 0x36, 0x99, 0x0d, 0xc0,
	0x9c, 0xd2, 0x04, 0x73, 0x45, 0x98, 0xbd, 0x5d, 0x51, 0xae, 0x24, 0xe6, 0x6e, 0x57, 0xd6, 0xfa,
	0x0e, 0x30, 0xef, 0x5f, 0xdf, 0x81, 0xde, 0x75, 0x36, 0x20, 0xb4, 0xdc, 0xbb, 0x36, 0xd1, 0xdc,
	0x91, 0xc4, 0xbd, 0xdb, 0x1d, 0xc9, 0x62, 0x3e, 0x89, 0xfb, 0x9e, 0xf9, 0x24, 0x5f, 0x61, 0x8d,
	0xfd, 0x44, 0xfd, 0xc5, 0x03, 0xa7, 0xca, 0x62, 0xbc, 0xcd, 0xa6, 0x4c, 0x7d, 0x08, 0x70, 0x27,
	0xcb, 0xc3, 0xa5, 0x24, 0x2c, 0xf8, 0x24, 0x95, 0x52, 0xe2, 0xa1, 0x4f, 0x4a, 0xde, 0x61, 0xac,
	0xa8, 0x4e, 0x81, 0x45, 0x27, 0xae, 0x08, 0xcb, 0x13, 0x1e, 0xd5, 0x78, 0xb2, 0xbc, 0xc4, 0xe3,
	0x1a, 0x2f, 0xcb, 0x9b, 0xdb, 0x55, 0x03, 0x7d, 0x3f, 0xe0, 0xbb, 0xb9, 0xc6, 0x94, 0xf7, 0xd0,
	0x8c, 0xbb, 0x3d, 0x3c, 0xf1, 0xdd, 0xc3, 0x5c, 0x95, 0x6b, 0xeb, 0xaa, 0x81, 0xc0, 0x92, 0x6f,
	0x6d, 0x5a, 0x58, 0x9e, 0xf0, 0xb4, 0xc6, 0x93, 0xe5, 0x25, 0x9e, 0xd5, 0x78, 0xc9, 0x77, 0xd8,
	0xbc, 0x19, 0xf5, 0x54, 0x70, 0xac, 0x37, 0xff, 0xdc, 0x99, 0x62, 0xa3, 0xf2, 0xbb, 0xa5, 0x7f,
	0x10, 0x78, 0xe1, 0xfb, 0x6e, 0x65, 0xc4, 0xce, 0x20, 0xbc, 0xac, 0xcb, 0x20, 0x3b, 0x43, 0x62,
	0xb9, 0x2e, 0xa3, 0xf2, 0x1e, 0x45, 0x1c, 0xeb, 0xad, 0xbc, 0xf2, 0xbd, 0x47, 0x63, 0xca, 0xf3,
	0x12, 0x71, 0x2c, 0xb0, 0xe2, 0x3b, 0x2f, 0x2d, 0x2c, 0x4f, 0x78, 0x5d, 0xe3, 0xc9, 0xf2, 0x12,
	0xab, 0x35, 0x5e, 0xea, 0xba, 0xca, 0xbe, 0x86, 0xfb, 0xc1, 0x71, 0x1a, 0x25, 0xe2, 0x62, 0x80,
	0x37, 0xee, 0xba, 0xb2, 0x95, 0xde, 0x7b, 0xf5, 0x17, 0xac, 0xb9, 0xf7, 0x5e, 0x35, 0x37, 0x72,
	0x08, 0x6f, 0x6b, 0x73, 0xe8, 0x46, 0x8e, 0x44, 0xbb, 0x36, 0x47, 0x16, 0x39, 0x79, 0x89, 0xbd,
	0xf3, 0xe4, 0xe4, 0x15, 0xd6, 0x61, 0xac, 0x18, 0x0b, 0xac, 0xbb, 0xcf, 0xad, 0x14, 0x96, 0x27,
	0xbc, 0xaf, 0xf1, 0x64, 0x79, 0x89, 0x8d, 0x1a, 0x2f, 0x75, 0x35, 0x9a, 0xae, 0x67, 0x4a, 0xeb,
	0x83, 0xbb, 0x1a, 0x2b, 0x44, 0x77, 0x8b, 0x7c, 0x28, 0xd0, 0x71, 0x77, 0x8b, 0x02, 0x54, 0x35,
	0xe1, 0xa3, 0x5f, 0x53, 0x55, 0x4b, 0x6c, 0xfa, 0xb5, 0xd4, 0xbd, 0x5f, 0x8e, 0x92, 0x44, 0x85,
	0xa9, 0xc0, 0x27, 0x77, 0xef, 0xcf, 0xe3, 0x15, 0x4b, 0xd8, 0xf2, 0x5a, 0xaa, 0x58, 0x89, 0x6d,
	0xaf, 0xcd, 0xba, 0xd7, 0x9e, 0x3a, 0x0b, 0xc2, 0x13, 0xec, 0xb8, 0xbb, 0x97, 0x89, 0xea, 0x9d,
	0x99, 0xa7, 0x5f, 0xa7, 0x21, 0x3e, 0xbb, 0x77, 0x56, 0x80, 0x8a, 0x0e, 0xae, 0xb0, 0xeb, 0xd5,
	0xc1, 0x55, 0xa9, 0x45, 0x1c, 0xe3, 0x8b, 0x4f, 0x8b, 0x38, 0xd6, 0xfd, 0x6c, 0x3c, 0xc0, 0x57,
	0x77, 0x3f, 0x1b, 0x87, 0x4b, 0x49, 0xf8, 0xe6, 0x93, 0x54, 0x4a, 0x89, 0xef, 0x3e, 0x29, 0x39,
	0x67, 0x8d, 0xf4, 0xf4, 0x4c, 0xe1, 0xc7, 0xf2, 0x44, 0xbb, 0xd1, 0xcb, 0x9e, 0xfb, 0xcd, 0xec,
	0x8f, 0xea, 0xf6, 0xff, 0x00, 0x00, 0x00, 0xff, 0xff, 0x57, 0xdd, 0x93, 0x73, 0xd7, 0x0a, 0x00,
	0x00,
}
